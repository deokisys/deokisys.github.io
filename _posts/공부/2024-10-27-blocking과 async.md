---
layout: post
title: blocking과 async
categories: 공부
tag: [blocking, non blocking, async, asynchronous, sync, synchronous, 네트워크]
toc: true
---

# blocking과 async

- 비동기와 blocking에 대해 정리해보자.

## blocking/non-blocking

- `제어권`을 건네주는 유무의 차이
- 함수A, 함수B가 존재하며 A안에서 B가 호출됐다고 가정
  - A를 실행하다가, B를 호출하면서 제어권을 받게 된다.
  - 이때 할일을 마치고 리턴해줄지, 바로 제어권을 리턴해줄지에 따라 block과 non-block이 나뉜다.
- 여기서 제어권을 실행하는 주체라고 생각해도 될듯하다.

## synchronous(동기)/asynchronous(비동기)

- 동기/비동기는 일을 수행중인 `동시성`에 주목
- 함수A, 함수B가 존재하며 A안에서 B가 호출됐다고 가정
  - `A가 B의 수행결과나 종료 상태를 A가 신경`쓰는 유무로 동기, 비동기로 나뉜다.
- 동기
  - A가 지속적으로 B가 끝났는지 확인을 한다.
- 비동기
  - A는 B가 끝나던, 안끝나던 신경은 안쓴다.
- 비동기는 Callback을 통해 작업 완료 여부를 호출한 함수에게 답한다.
  - Callback을 통해 끝나는것을 기다리지 않고 자신이 할일 한다.

### 비동기와 논브록킹이 햇갈려요!

- 논블로킹은 제어권을 바로 전달해주는 방식
  - A가 B를 호출하면, B는 "이따가 결과를 줄게, 나중에 확인해"하고 `제어권`을 바로 넘겨주면서 일단 응답을 하고 시작
- 비동기는 일단 결과는 신경 안쓰고 완료되었다는 이벤트/콜백/promise로 확인하는 방식이다.
- 여기서 차이가 느껴지는가? 즉시 제어권을 돌려주면서 나중에 확인해라고 응답을 해주고 할일 하는게 논블로킹, 끝났을때 나 끝났어요 하고 알리는게 비동기이다.
- 그래서 비동기-논브로킹로 같이 사용
  - 논브로킹으로 일단 A가 B를 호출하고 A는 할일을 한다.
    - 비동기이므로 A는 B의 결과를 신경안쓴다.
  - B는 비동기로 자신이 끝났을때 A에게 나 끝났다고 알려주게된다.

## 총정리

### 블로킹 Blocking

- A 함수가 B 함수를 호출 할 때, B 함수가 자신의 작업이 종료되기 전까지 A 함수에게 **`제어권`**을 돌려주지 않는 것

### 논블로킹 Non-blocking

- A 함수가 B 함수를 호출 할 때, B 함수가 **`제어권`**을 바로 A 함수에게 넘겨주면서, A 함수가 다른 일을 할 수 있도록 하는 것.

### 동기 Synchronous

- A 함수가 B 함수를 호출 할 때, B 함수의 결과를 지속적으로 확인하는것

### 비동기 Asynchronous

- A 함수가 B 함수를 호출 할 때, B 함수는 결과를 처리하고 A에게 알리는것 (callback)

![총정리 그림](https://github.com/user-attachments/assets/6124d0cd-da36-4ce4-8f76-ee81d0847d27)

### 동기 논블로킹은 뭐죠?

- 개념은 존재하지만, 실무에선 드문 방식
- 동기는?
  - A가 B를 호출하면 B가 완료되는것을 확인하는 방식
- 논블로킹은?
  - A가 B를 호출해도 제어권이 일단 A에게 바로 넘어가서 할일을 하는 방식
- 흐름을 봅시다.
  - 일단 바로 A는 B를 호출하지만 A가 제어권을 받고 할일을 합니다.
  - 하지만 동기이므로, A는 B의 결과를 신경쓰고 지속적으로 결과를 확인하게 됩니다.
    - 지속적으로 다 됐니? 라는 요청을 보냅니다.
  - A에 제어권이 있으므로 A는 할일을 합니다. B의 결과가 오기를 기다리면서
- 안쓰는이유
  - 누가봐도 안쓸 형태이다.
  - 자원을 너무 낭비하며, 비효율적이다.
